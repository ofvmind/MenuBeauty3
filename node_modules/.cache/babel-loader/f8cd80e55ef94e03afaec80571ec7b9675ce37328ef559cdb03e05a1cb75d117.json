{"ast":null,"code":"// drag\n(function (window, factory) {\n  // universal module definition\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'unidragger/unidragger', 'fizzy-ui-utils/utils'], function (Flickity, Unidragger, utils) {\n      return factory(window, Flickity, Unidragger, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./flickity'), require('unidragger'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, Unidragger, utils) {\n  'use strict';\n\n  // ----- defaults ----- //\n  utils.extend(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  });\n\n  // ----- create ----- //\n\n  Flickity.createMethods.push('_createDrag');\n\n  // -------------------------- drag prototype -------------------------- //\n\n  var proto = Flickity.prototype;\n  utils.extend(proto, Unidragger.prototype);\n  proto._touchActionValue = 'pan-y';\n\n  // --------------------------  -------------------------- //\n\n  proto._createDrag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable);\n    // TODO updateDraggable on resize? if groupCells & slides change\n  };\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable == '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n    if (this.isDraggable) {\n      this.element.classList.add('is-draggable');\n    } else {\n      this.element.classList.remove('is-draggable');\n    }\n  };\n\n  // backwards compatibility\n  proto.bindDrag = function () {\n    this.options.draggable = true;\n    this.updateDraggable();\n  };\n  proto.unbindDrag = function () {\n    this.options.draggable = false;\n    this.updateDraggable();\n  };\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  };\n\n  // -------------------------- pointer events -------------------------- //\n\n  proto.pointerDown = function (event, pointer) {\n    if (!this.isDraggable) {\n      this._pointerDownDefault(event, pointer);\n      return;\n    }\n    var isOkay = this.okayPointerDown(event);\n    if (!isOkay) {\n      return;\n    }\n    this._pointerDownPreventDefault(event);\n    this.pointerDownFocus(event);\n    // blur\n    if (document.activeElement != this.element) {\n      // do not blur if already focused\n      this.pointerDownBlur();\n    }\n\n    // stop if it was moving\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down');\n    // track scrolling\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n    this._pointerDownDefault(event, pointer);\n  };\n\n  // default pointerDown logic, used for staticClick\n  proto._pointerDownDefault = function (event, pointer) {\n    // track start event position\n    // Safari 9 overrides pageX and pageY. These values needs to be copied. #779\n    this.pointerDownPointer = {\n      pageX: pointer.pageX,\n      pageY: pointer.pageY\n    };\n    // bind move and end events\n    this._bindPostStartEvents(event);\n    this.dispatchEvent('pointerDown', event, [pointer]);\n  };\n  var focusNodes = {\n    INPUT: true,\n    TEXTAREA: true,\n    SELECT: true\n  };\n  proto.pointerDownFocus = function (event) {\n    var isFocusNode = focusNodes[event.target.nodeName];\n    if (!isFocusNode) {\n      this.focus();\n    }\n  };\n  proto._pointerDownPreventDefault = function (event) {\n    var isTouchStart = event.type == 'touchstart';\n    var isTouchPointer = event.pointerType == 'touch';\n    var isFocusNode = focusNodes[event.target.nodeName];\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) {\n      event.preventDefault();\n    }\n  };\n\n  // ----- move ----- //\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  };\n\n  // ----- up ----- //\n\n  proto.pointerUp = function (event, pointer) {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n    this.dispatchEvent('pointerUp', event, [pointer]);\n    this._dragPointerUp(event, pointer);\n  };\n  proto.pointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  };\n\n  // -------------------------- dragging -------------------------- //\n\n  proto.dragStart = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n    this.dispatchEvent('dragStart', event, [pointer]);\n  };\n  proto.pointerMove = function (event, pointer) {\n    var moveVector = this._dragPointerMove(event, pointer);\n    this.dispatchEvent('pointerMove', event, [pointer, moveVector]);\n    this._dragMove(event, pointer, moveVector);\n  };\n  proto.dragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) {\n      return;\n    }\n    event.preventDefault();\n    this.previousDragX = this.dragX;\n    // reverse if right-to-left\n    var direction = this.options.rightToLeft ? -1 : 1;\n    if (this.options.wrapAround) {\n      // wrap around move. #589\n      moveVector.x %= this.slideableWidth;\n    }\n    var dragX = this.dragStartPosition + moveVector.x * direction;\n    if (!this.options.wrapAround && this.slides.length) {\n      // slow drag\n      var originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      var endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n    this.dragX = dragX;\n    this.dragMoveTime = new Date();\n    this.dispatchEvent('dragMove', event, [pointer, moveVector]);\n  };\n  proto.dragEnd = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n    if (this.options.freeScroll) {\n      this.isFreeScrolling = true;\n    }\n    // set selectedIndex based on where flick will end up\n    var index = this.dragEndRestingSelect();\n    if (this.options.freeScroll && !this.options.wrapAround) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      var restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!this.options.freeScroll && index == this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n    delete this.previousDragX;\n    // apply selection\n    // TODO refactor this, selecting here feels weird\n    // HACK, set flag so dragging stays in correct direction\n    this.isDragSelect = this.options.wrapAround;\n    this.select(index);\n    delete this.isDragSelect;\n    this.dispatchEvent('dragEnd', event, [pointer]);\n  };\n  proto.dragEndRestingSelect = function () {\n    var restingX = this.getRestingPosition();\n    // how far away from selected slide\n    var distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex));\n    // get closet resting going up and going down\n    var positiveResting = this._getClosestResting(restingX, distance, 1);\n    var negativeResting = this._getClosestResting(restingX, distance, -1);\n    // use closer resting for wrap-around\n    var index = positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n    return index;\n  };\n\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n  proto._getClosestResting = function (restingX, distance, increment) {\n    var index = this.selectedIndex;\n    var minDistance = Infinity;\n    var condition = this.options.contain && !this.options.wrapAround ?\n    // if contain, keep going if distance is equal to minDistance\n    function (dist, minDist) {\n      return dist <= minDist;\n    } : function (dist, minDist) {\n      return dist < minDist;\n    };\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n      if (distance === null) {\n        break;\n      }\n      distance = Math.abs(distance);\n    }\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x - horizontal position\n   * @param {Integer} index - slide index\n   * @returns {Number} - slide distance\n   */\n  proto.getSlideDistance = function (x, index) {\n    var len = this.slides.length;\n    // wrap around if at least 2 slides\n    var isWrapAround = this.options.wrapAround && len > 1;\n    var slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    var slide = this.slides[slideIndex];\n    if (!slide) {\n      return null;\n    }\n    // add distance for wrap-around slides\n    var wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n    var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    var delta = this.previousDragX - this.dragX;\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n    return 0;\n  };\n\n  // ----- staticClick ----- //\n\n  proto.staticClick = function (event, pointer) {\n    // get clickedCell, if cell was clicked\n    var clickedCell = this.getParentCell(event.target);\n    var cellElem = clickedCell && clickedCell.element;\n    var cellIndex = clickedCell && this.cells.indexOf(clickedCell);\n    this.dispatchEvent('staticClick', event, [pointer, cellElem, cellIndex]);\n  };\n\n  // ----- scroll ----- //\n\n  proto.onscroll = function () {\n    var scroll = getScrollPosition();\n    var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    var scrollMoveY = this.pointerDownScroll.y - scroll.y;\n    // cancel click/tap if scroll is too much\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this._pointerDone();\n    }\n  };\n\n  // ----- utils ----- //\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n\n  // -----  ----- //\n\n  return Flickity;\n});","map":{"version":3,"names":["window","factory","define","amd","Flickity","Unidragger","utils","module","exports","require","fizzyUIUtils","extend","defaults","draggable","dragThreshold","createMethods","push","proto","prototype","_touchActionValue","_createDrag","on","onActivateDrag","_uiChangeDrag","onDeactivateDrag","updateDraggable","handles","viewport","bindHandles","unbindHandles","element","classList","remove","options","isDraggable","slides","length","add","bindDrag","unbindDrag","isFreeScrolling","pointerDown","event","pointer","_pointerDownDefault","isOkay","okayPointerDown","_pointerDownPreventDefault","pointerDownFocus","document","activeElement","pointerDownBlur","dragX","x","pointerDownScroll","getScrollPosition","addEventListener","pointerDownPointer","pageX","pageY","_bindPostStartEvents","dispatchEvent","focusNodes","INPUT","TEXTAREA","SELECT","isFocusNode","target","nodeName","focus","isTouchStart","type","isTouchPointer","pointerType","preventDefault","hasDragStarted","moveVector","Math","abs","pointerUp","isTouchScrolling","_dragPointerUp","pointerDone","removeEventListener","dragStart","dragStartPosition","startAnimation","pointerMove","_dragPointerMove","_dragMove","dragMove","previousDragX","direction","rightToLeft","wrapAround","slideableWidth","originBound","max","endBound","min","getLastSlide","dragMoveTime","Date","dragEnd","freeScroll","index","dragEndRestingSelect","restingX","getRestingPosition","selectedIndex","dragEndBoostSelect","isDragSelect","select","distance","getSlideDistance","positiveResting","_getClosestResting","negativeResting","increment","minDistance","Infinity","condition","contain","dist","minDist","len","isWrapAround","slideIndex","modulo","slide","wrap","floor","undefined","delta","staticClick","clickedCell","getParentCell","cellElem","cellIndex","cells","indexOf","onscroll","scroll","scrollMoveX","scrollMoveY","y","_pointerDone","pageXOffset","pageYOffset"],"sources":["C:/Users/user/Desktop/projects/MenuBeauty3/node_modules/flickity/js/drag.js"],"sourcesContent":["// drag\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'unidragger/unidragger',\n      'fizzy-ui-utils/utils',\n    ], function( Flickity, Unidragger, utils ) {\n      return factory( window, Flickity, Unidragger, utils );\n    } );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./flickity'),\n        require('unidragger'),\n        require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    window.Flickity = factory(\n        window,\n        window.Flickity,\n        window.Unidragger,\n        window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, Unidragger, utils ) {\n\n'use strict';\n\n// ----- defaults ----- //\n\nutils.extend( Flickity.defaults, {\n  draggable: '>1',\n  dragThreshold: 3,\n} );\n\n// ----- create ----- //\n\nFlickity.createMethods.push('_createDrag');\n\n// -------------------------- drag prototype -------------------------- //\n\nvar proto = Flickity.prototype;\nutils.extend( proto, Unidragger.prototype );\nproto._touchActionValue = 'pan-y';\n\n// --------------------------  -------------------------- //\n\nproto._createDrag = function() {\n  this.on( 'activate', this.onActivateDrag );\n  this.on( 'uiChange', this._uiChangeDrag );\n  this.on( 'deactivate', this.onDeactivateDrag );\n  this.on( 'cellChange', this.updateDraggable );\n  // TODO updateDraggable on resize? if groupCells & slides change\n};\n\nproto.onActivateDrag = function() {\n  this.handles = [ this.viewport ];\n  this.bindHandles();\n  this.updateDraggable();\n};\n\nproto.onDeactivateDrag = function() {\n  this.unbindHandles();\n  this.element.classList.remove('is-draggable');\n};\n\nproto.updateDraggable = function() {\n  // disable dragging if less than 2 slides. #278\n  if ( this.options.draggable == '>1' ) {\n    this.isDraggable = this.slides.length > 1;\n  } else {\n    this.isDraggable = this.options.draggable;\n  }\n  if ( this.isDraggable ) {\n    this.element.classList.add('is-draggable');\n  } else {\n    this.element.classList.remove('is-draggable');\n  }\n};\n\n// backwards compatibility\nproto.bindDrag = function() {\n  this.options.draggable = true;\n  this.updateDraggable();\n};\n\nproto.unbindDrag = function() {\n  this.options.draggable = false;\n  this.updateDraggable();\n};\n\nproto._uiChangeDrag = function() {\n  delete this.isFreeScrolling;\n};\n\n// -------------------------- pointer events -------------------------- //\n\nproto.pointerDown = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    this._pointerDownDefault( event, pointer );\n    return;\n  }\n  var isOkay = this.okayPointerDown( event );\n  if ( !isOkay ) {\n    return;\n  }\n\n  this._pointerDownPreventDefault( event );\n  this.pointerDownFocus( event );\n  // blur\n  if ( document.activeElement != this.element ) {\n    // do not blur if already focused\n    this.pointerDownBlur();\n  }\n\n  // stop if it was moving\n  this.dragX = this.x;\n  this.viewport.classList.add('is-pointer-down');\n  // track scrolling\n  this.pointerDownScroll = getScrollPosition();\n  window.addEventListener( 'scroll', this );\n\n  this._pointerDownDefault( event, pointer );\n};\n\n// default pointerDown logic, used for staticClick\nproto._pointerDownDefault = function( event, pointer ) {\n  // track start event position\n  // Safari 9 overrides pageX and pageY. These values needs to be copied. #779\n  this.pointerDownPointer = {\n    pageX: pointer.pageX,\n    pageY: pointer.pageY,\n  };\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.dispatchEvent( 'pointerDown', event, [ pointer ] );\n};\n\nvar focusNodes = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n};\n\nproto.pointerDownFocus = function( event ) {\n  var isFocusNode = focusNodes[ event.target.nodeName ];\n  if ( !isFocusNode ) {\n    this.focus();\n  }\n};\n\nproto._pointerDownPreventDefault = function( event ) {\n  var isTouchStart = event.type == 'touchstart';\n  var isTouchPointer = event.pointerType == 'touch';\n  var isFocusNode = focusNodes[ event.target.nodeName ];\n  if ( !isTouchStart && !isTouchPointer && !isFocusNode ) {\n    event.preventDefault();\n  }\n};\n\n// ----- move ----- //\n\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > this.options.dragThreshold;\n};\n\n// ----- up ----- //\n\nproto.pointerUp = function( event, pointer ) {\n  delete this.isTouchScrolling;\n  this.viewport.classList.remove('is-pointer-down');\n  this.dispatchEvent( 'pointerUp', event, [ pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto.pointerDone = function() {\n  window.removeEventListener( 'scroll', this );\n  delete this.pointerDownScroll;\n};\n\n// -------------------------- dragging -------------------------- //\n\nproto.dragStart = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  this.dragStartPosition = this.x;\n  this.startAnimation();\n  window.removeEventListener( 'scroll', this );\n  this.dispatchEvent( 'dragStart', event, [ pointer ] );\n};\n\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  event.preventDefault();\n\n  this.previousDragX = this.dragX;\n  // reverse if right-to-left\n  var direction = this.options.rightToLeft ? -1 : 1;\n  if ( this.options.wrapAround ) {\n    // wrap around move. #589\n    moveVector.x %= this.slideableWidth;\n  }\n  var dragX = this.dragStartPosition + moveVector.x * direction;\n\n  if ( !this.options.wrapAround && this.slides.length ) {\n    // slow drag\n    var originBound = Math.max( -this.slides[0].target, this.dragStartPosition );\n    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;\n    var endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );\n    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;\n  }\n\n  this.dragX = dragX;\n\n  this.dragMoveTime = new Date();\n  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  if ( this.options.freeScroll ) {\n    this.isFreeScrolling = true;\n  }\n  // set selectedIndex based on where flick will end up\n  var index = this.dragEndRestingSelect();\n\n  if ( this.options.freeScroll && !this.options.wrapAround ) {\n    // if free-scroll & not wrap around\n    // do not free-scroll if going outside of bounding slides\n    // so bounding slides can attract slider, and keep it in bounds\n    var restingX = this.getRestingPosition();\n    this.isFreeScrolling = -restingX > this.slides[0].target &&\n      -restingX < this.getLastSlide().target;\n  } else if ( !this.options.freeScroll && index == this.selectedIndex ) {\n    // boost selection if selected index has not changed\n    index += this.dragEndBoostSelect();\n  }\n  delete this.previousDragX;\n  // apply selection\n  // TODO refactor this, selecting here feels weird\n  // HACK, set flag so dragging stays in correct direction\n  this.isDragSelect = this.options.wrapAround;\n  this.select( index );\n  delete this.isDragSelect;\n  this.dispatchEvent( 'dragEnd', event, [ pointer ] );\n};\n\nproto.dragEndRestingSelect = function() {\n  var restingX = this.getRestingPosition();\n  // how far away from selected slide\n  var distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );\n  // get closet resting going up and going down\n  var positiveResting = this._getClosestResting( restingX, distance, 1 );\n  var negativeResting = this._getClosestResting( restingX, distance, -1 );\n  // use closer resting for wrap-around\n  var index = positiveResting.distance < negativeResting.distance ?\n    positiveResting.index : negativeResting.index;\n  return index;\n};\n\n/**\n * given resting X and distance to selected cell\n * get the distance and index of the closest cell\n * @param {Number} restingX - estimated post-flick resting position\n * @param {Number} distance - distance to selected cell\n * @param {Integer} increment - +1 or -1, going up or down\n * @returns {Object} - { distance: {Number}, index: {Integer} }\n */\nproto._getClosestResting = function( restingX, distance, increment ) {\n  var index = this.selectedIndex;\n  var minDistance = Infinity;\n  var condition = this.options.contain && !this.options.wrapAround ?\n    // if contain, keep going if distance is equal to minDistance\n    function( dist, minDist ) {\n      return dist <= minDist;\n    } : function( dist, minDist ) {\n      return dist < minDist;\n    };\n  while ( condition( distance, minDistance ) ) {\n    // measure distance to next cell\n    index += increment;\n    minDistance = distance;\n    distance = this.getSlideDistance( -restingX, index );\n    if ( distance === null ) {\n      break;\n    }\n    distance = Math.abs( distance );\n  }\n  return {\n    distance: minDistance,\n    // selected was previous index\n    index: index - increment,\n  };\n};\n\n/**\n * measure distance between x and a slide target\n * @param {Number} x - horizontal position\n * @param {Integer} index - slide index\n * @returns {Number} - slide distance\n */\nproto.getSlideDistance = function( x, index ) {\n  var len = this.slides.length;\n  // wrap around if at least 2 slides\n  var isWrapAround = this.options.wrapAround && len > 1;\n  var slideIndex = isWrapAround ? utils.modulo( index, len ) : index;\n  var slide = this.slides[ slideIndex ];\n  if ( !slide ) {\n    return null;\n  }\n  // add distance for wrap-around slides\n  var wrap = isWrapAround ? this.slideableWidth * Math.floor( index/len ) : 0;\n  return x - ( slide.target + wrap );\n};\n\nproto.dragEndBoostSelect = function() {\n  // do not boost if no previousDragX or dragMoveTime\n  if ( this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100 ) {\n    return 0;\n  }\n\n  var distance = this.getSlideDistance( -this.dragX, this.selectedIndex );\n  var delta = this.previousDragX - this.dragX;\n  if ( distance > 0 && delta > 0 ) {\n    // boost to next if moving towards the right, and positive velocity\n    return 1;\n  } else if ( distance < 0 && delta < 0 ) {\n    // boost to previous if moving towards the left, and negative velocity\n    return -1;\n  }\n  return 0;\n};\n\n// ----- staticClick ----- //\n\nproto.staticClick = function( event, pointer ) {\n  // get clickedCell, if cell was clicked\n  var clickedCell = this.getParentCell( event.target );\n  var cellElem = clickedCell && clickedCell.element;\n  var cellIndex = clickedCell && this.cells.indexOf( clickedCell );\n  this.dispatchEvent( 'staticClick', event, [ pointer, cellElem, cellIndex ] );\n};\n\n// ----- scroll ----- //\n\nproto.onscroll = function() {\n  var scroll = getScrollPosition();\n  var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n  var scrollMoveY = this.pointerDownScroll.y - scroll.y;\n  // cancel click/tap if scroll is too much\n  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {\n    this._pointerDone();\n  }\n};\n\n// ----- utils ----- //\n\nfunction getScrollPosition() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset,\n  };\n}\n\n// -----  ----- //\n\nreturn Flickity;\n\n} ) );\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}